library(secr)
library(MASS)

# Mean life time of scat
MEAN_LIFE <- 365 / 2
# Mean droppings left per day
DROP_RATE <- 0.5
# Mean time before leaving area
MEAN_STAY <- 365
# Variance in the time spent in area
VAR_STAY <- (56 / 1.96) ** 2
# Length of side of study site
SITE_LENGTH <- 200
# Range parameter for single leopard
RANGE <- 50

# This function simulates the dropping information of one individual leopard, given period of occupation and number of droppings
# Inputs: arrived   - Time that the individual arrived in the study site
#         left      - Time that the individual left the study site
#         droppings - Number of droppings created by the individual during their time in the study area
#
# Outputs: A list of six variables:
#          activity_centre - The geographic centre of the individuals activity
#          present         - The time interval the individual was present for
#          drop_times      - The times a dropping was created by the individual
#          surv_times      - The "survival" time of the droppings, which is the time the dropping lasts until degrading beyond genotyping
#          decay_times     - The time at which the dropping degrades beyond genotyping
individual <- function(arrived, left, droppings){
  # Simulate the dropping, survival, and decay times as defined above
  drop_times <- runif(droppings, arrived, left)
  surv_times <- rexp(droppings, 1 / MEAN_LIFE)
  decay_times <- drop_times + surv_times
  
  # Simulate the activity centre of the individual
  # The coordinates are modelled as independent uniform random variables, centred on (0, 0)
  activity_centre <- runif(2, -SITE_LENGTH/2, SITE_LENGTH/2)
  # Simulate the location of the droppings
  # The droppings are independent normal random variables centered on the activity centre
  location <- t(mvrnorm(droppings, activity_centre, RANGE * diag(c(1, 1))))
  
  # Return the simulated information in a list
  return(list(activity_centre = activity_centre,
              present = c(arrived, left),
              drop_times = drop_times,
              surv_times = surv_times,
              decay_times = decay_times,
              location = location))
}

# This function simulates the dropping information of a population of leopards
# Inputs: N - The number of animals that use the study site in [0, T]
#         T - The time at which the SCR study commences
# Outputs: individuals - A list of N individuals with the information generated by individual()
population <- function(N, T){
  # Simulate the times of arrival into the study of area, uniform on [0, T]
  arrivals <- runif(N, 0, T)
  # Simulate the time the individuals stay in the area
  # This is modelled as a gamma random variable with specified mean and variance
  stay_time <- rgamma(N, shape = MEAN_STAY ** 2 / VAR_STAY, rate = MEAN_STAY / VAR_STAY)
  # Calculate the time of departure
  departures <- arrivals + stay_time
  
  # Initialise a list to store individuals
  individuals <- vector("list", N)
  for(i in 1:N){
    # Calculate the expected number of droppings
    expected_droppings <- DROP_RATE * (departures[i] - arrivals[i])
    # Simulate information on each individual
    individuals[[i]] <- individual(arrivals[i], departures[i], rpois(1, expected_droppings))
  }
  
  return(individuals)
}

# This function simulates the population with a queue (G/G/infinity I think)
# Inputs: N0 - Initial number of individuals in the population, also the expected number
#          T - Time to simulate the population for
# Outputs: A list of four elements
#          individuals - A data frame with the time interval each individual was present for
#                times - A vector with times at which the population changes
#           population - Each element is the population in the area as of the corresponding time in times
queue <- function(N0, T){
  # Set parameters of the gamma distribution by matching moments
  shape <- MEAN_STAY ** 2 / VAR_STAY
  rate <-  MEAN_STAY / VAR_STAY
  
  # Initialise the individuals data frame as described above
  # Assume N0 individuals simultaneous arrive at t=0
  # Departure times are assumed to be gamma distributed
  individuals <- data.frame(arrival = rep(0, N0),
                            departure = rgamma(N0, shape, rate))
  
  # Generate the time at which the next individual moves into the area
  # The shape paramater is adjusted in order to specify the stationary expectation
  latest <- rgamma(1, shape / N0, rate)
  # Simulate arrival times until the simlation period has elapsed
  while(latest < T){
    # Draw the new arrival's length of stay, and append this to the data frame
    stay_time <- rgamma(1, shape, rate)
    individuals <- rbind(individuals, c(latest, latest + stay_time))
    
    # Draw next arrival time
    latest <- latest + rgamma(1, shape / N0, rate)
  }
  
  # Find how many individuals have been present in total
  n_individs <- dim(individuals)[1]
  # Convert the data frame to a matrix
  individuals <- as.matrix(individuals)
  
  # "Unroll" all times into one vector
  # The first n_individs are the arrival times, the rest are departure times
  times <- as.vector(individuals)
  # Specifcy the instantaneous change in population at the times in times
  # For the arrival times this is +1, and the departures it is -1
  change <- c(rep(1, n_individs), rep(-1, n_individs))

  # Order both change and times in chronological order
  change <- change[order(times)]
  times <- sort(times)
  
  # Condense the N0 elements at t=0 down to a single entry
  last_zero <- max(which(times == 0))
  times <- times[last_zero:length(times)]
  change <- change[last_zero:length(change)]
  
  # Calculate the abundance at each time point
  population <- N0 + cumsum(change)
  
  # Return the simulated information
  list(individuals = individuals,
       times = times,
       change = change,
       population = population)
}


# Simulate the study site for three years, with N individuals present in that time
N <- 30
pop <- population(N, 365 * 3)

# Create a list to store the transect lines
transect_list <- vector("list", 11)
for(i in 1:11){
  # Start with a data frame with two columns and two rows
  # The first row is the start point, the second row is the finish point
  # Each transect runs from x = -100 to x = 100, and is at constant height
  # Transects are stacked vertically, 20 units apart
  transect_list[[i]] <- data.frame(x = c(-100, 100), y = rep(-100 + (i - 1) * 20, 2))
}

# Convert to a list of secr transect objects
transect_list <- make.transect(transect_list)
# Plot the transect lines
plot(transect_list)

# Iterate over the population
for(i in 1:N){
  ind <- pop[[i]]
  # Extract the droppings which are still present at the commencation of the SCR study
  locations <- matrix(ind$location[, which(ind$decay_times >= 3 * 365)], nrow = 2)
  # Plot these locations
  points(locations[1,], locations[2,], pch = 19, cex = 0.5, col = 'blue')
  
  # Plot the activity centres, green if it's present at the start of the study, red if it is not
  if(ind$present[2] >= 1095){
    points(ind$activity_centre[1], ind$activity_centre[2], pch = 19, cex = 1.5, col = 'green')
  }
  else{
    points(ind$activity_centre[1], ind$activity_centre[2], pch = 19, cex = 1.5, col = 'red')
  }
}

# Convert the locations to a form usable by secr
# This takes the form of a list with one element per individual
# Each individual's list element contains a data frame with the x and y coordinates of the droppings present at survey time
droppings <- vector("list", 0)
for(i in 1:N){
  ind <- pop[[i]]
  
  # Identify which (if any) droppings are present at the time of the survey
  survived <- which(ind$decay_times >= 3 * 365)
  
  # If droppings are present, extract their locations
  if(length(survived) > 0){
    location <- matrix(ind$location[, survived], nrow = 2)
    
    droppings <- c(droppings, vector("list", 1))
    droppings[[length(droppings)]] <- data.frame(x = location[1, ], y = location[2, ])
  }
}

capthist <- sim.capthist(traps = transect_list,
                         popn = droppings,
                         detectfn = 'HHN',
                         detectpar = list(lambda0 = 0.5, sigma = 50),
                         noccasions = 3)

mod <- secr.fit(capthist = capthist)
