library(secr)
library(MASS)
library(dplyr)

# Mean life time of scat
MEAN_LIFE <- 365 / 2
# Mean droppings left per day
DROP_RATE <- 0.5
# Mean time before leaving area
MEAN_STAY <- 365
# Variance in the time spent in area
VAR_STAY <- (56 / 1.96) ** 2
# Length of side of study site
SITE_LENGTH <- 200
# Range parameter for single leopard
RANGE <- 50

# This function simulates the dropping information of one individual leopard, given period of occupation and number of droppings
# Inputs: arrived   - Time that the individual arrived in the study site
#         left      - Time that the individual left the study site
#         droppings - Number of droppings created by the individual during their time in the study area
#
# Outputs: A list of six variables:
#          activity_centre - The geographic centre of the individuals activity
#          present         - The time interval the individual was present for
#          drop_times      - The times a dropping was created by the individual
#          surv_times      - The "survival" time of the droppings, which is the time the dropping lasts until degrading beyond genotyping
#          decay_times     - The time at which the dropping degrades beyond genotyping
individual <- function(arrived, left){
  # Simulate the dropping, survival, and decay times as defined above
  droppings <- rpois(1, DROP_RATE * (left - arrived))
  drop_times <- runif(droppings, arrived, left)
  surv_times <- rexp(droppings, 1 / MEAN_LIFE)
  decay_times <- drop_times + surv_times
  
  # Simulate the activity centre of the individual
  # The coordinates are modelled as independent uniform random variables, centred on (0, 0)
  activity_centre <- runif(2, -SITE_LENGTH/2, SITE_LENGTH/2)
  # Simulate the location of the droppings
  # The droppings are independent normal random variables centered on the activity centre
  location <- t(mvrnorm(droppings, activity_centre, RANGE * diag(c(1, 1))))
  
  # Return the simulated information in a list
  return(list(activity_centre = activity_centre,
              present = c(arrived, left),
              drop_times = drop_times,
              surv_times = surv_times,
              decay_times = decay_times,
              location = location))
}


# This function simulates the population with a queue (G/G/infinity I think)
# Inputs:  N - Asymptotic expected number of individuals in the population
#          T - Time to simulate the population for
# Outputs: A list of four elements
#          individuals - A data frame with the time interval each individual was present for
#                times - A vector with times at which the population changes
#           population - Each element is the population in the area as of the corresponding time in times
queue <- function(N, T){
  # Set parameters of the gamma distribution by matching moments
  shape <- MEAN_STAY ** 2 / VAR_STAY
  rate <-  MEAN_STAY / VAR_STAY
  
  # Initialise the individuals data frame
  individuals <- data.frame(arrival = double(),
                            departure = double())
  
  # Generate the time at which the next individual moves into the area
  # The shape paramater is adjusted in order to specify the stationary expectation
  latest <- rgamma(1, shape / N, rate)
  # Simulate arrival times until the simlation period has elapsed
  while(latest < T){
    # Draw the new arrival's length of stay, and append this to the data frame
    stay_time <- rgamma(1, shape, rate)
    individuals <- rbind(individuals,
                         list(arrival = latest, departure = latest + stay_time))
    
    # Draw next arrival time
    latest <- latest + rgamma(1, shape / N, rate)
  }
  
  # Find how many individuals have been present in total
  n_individs <- dim(individuals)[1]
  # Convert the data frame to a matrix
  individuals <- as.matrix(individuals)
  
  # "Unroll" all times into one vector
  # The first n_individs are the arrival times, the rest are departure times
  times <- as.vector(individuals)
  # Specify the instantaneous change in population at the times in times
  # For the arrival times this is +1, and the departures it is -1
  change <- rep(c(1, -1), c(n_individs, n_individs))
  
  # Order both change and times in chronological order
  change <- change[order(times)]
  times <- sort(times)
  
  # Calculate the abundance at each time point
  population <- cumsum(change)
  
  # Return the simulated information
  list(individuals = individuals,
       times = times,
       change = change,
       population = population)
}


# This function simulates the dropping information of a population of leopards
# Inputs: N - The asymptotic expected number of individuals
#         T - The time at which the SCR study commences
# Outputs: individuals - A list of N individuals with the information generated by individual()
population <- function(N, T){
  # Simulate occupancy history of the area
  history <- queue(N, T)$individuals
  N_tot <- dim(history)[1]
  
  # Initialise a list to store individuals
  individuals <- vector("list", N_tot)
  
  for(i in 1:N_tot){
    present <- history[i, ]
    # Simulate information on each individual
    individuals[[i]] <- individual(present[1], present[2])
  }
  
  return(individuals)
}



# Simulate the study site for three years, with N expected individuals
N_exp <- 30
pop <- population(N_exp, 365 * 3)

# Create a blank plot - this will eventually show the spatial locations of activity centres and droppings
plot(c(-SITE_LENGTH/2, SITE_LENGTH/2, -SITE_LENGTH/2, SITE_LENGTH/2),
     c(-SITE_LENGTH/2, SITE_LENGTH/2, SITE_LENGTH/2, -SITE_LENGTH/2),
     type = 'n', xlab = "Longitude", ylab = "Latitude")

# Iterate over the population
N <- length(pop)
for(i in 1:N){
  ind <- pop[[i]]
  # Extract the droppings which are still present at the commencation of the SCR study
  locations <- matrix(ind$location[, which(ind$decay_times >= 3 * 365)], nrow = 2)
  # Plot these locations
  points(locations[1,], locations[2,], pch = 19, cex = 0.5, col = 'blue')
  
  # Plot the activity centres, green if it's present at the start of the study, red if it is not
  if(ind$present[2] >= 1095){
    points(ind$activity_centre[1], ind$activity_centre[2], pch = 19, cex = 1.5, col = 'green')
  }
  else{
    points(ind$activity_centre[1], ind$activity_centre[2], pch = 19, cex = 1.5, col = 'red')
  }
}

# Add a legend
legend(-100, 100, c("Present", "Departed", "Dropping"),
       col = c('green', 'red', 'blue'),
       pch = 19)

# Now explore the issue of "prolonged detectability"
# Define a number of simulations to run, and define vectors to store results
B <- 200
N_present <- numeric(B)
N_detectable <- numeric(B)

# Sys.time() # Time how long the simulations take
# Run simulations - Takes ~7 minutes on my machine
for(i in 1:B){
  # Pick a number of expected individuals
  N_exp <- sample(5:100, 1)
  # Generate 101 years of data
  # The survey is carried out at t=100 years
  # The first 100 years are for burn in, and to ensure no droppings would be present at t=100 that were dropped before t=0
  # The last year is to avoid the tail behaviour that occurs as the simulation ends
  pop <- population(N_exp, 365 * 101)
  
  # Iterate over all animals that were present
  for(j in 1:length(pop)){
    # If animal j was present at t=100 years, increment the value in the presence vector
    if(between(365 * 100, pop[[j]]$present[1], pop[[j]]$present[2])){
      N_present[i] <- N_present[i] + 1
    }
    
    # If any of animals j's droppings were present at t=100 years, increment the value in the detectable vector
    if(any(pop[[j]]$drop_times <= 365 * 100 & pop[[j]]$decay_times >= 365 * 100)){
      N_detectable[i] <- N_detectable[i] + 1
    }
  }
}

# Plot the results
plot(N_present, N_detectable)
abline(0, 1)
beep()

# Sys.time() # End timing

# Now run a SCR study
# Convert the locations to a form usable by secr
# This takes the form of a list with one element per individual
# Each individual's list element contains a data frame with the x and y coordinates of the droppings present at survey time
droppings <- vector("list", 0)
for(i in 1:N){
  ind <- pop[[i]]
  
  # Identify which (if any) droppings are present at the time of the survey
  survived <- which(ind$decay_times >= 3 * 365)
  
  # If droppings are present, extract their locations
  if(length(survived) > 0){
    location <- matrix(ind$location[, survived], nrow = 2)
    
    droppings <- c(droppings, vector("list", 1))
    droppings[[length(droppings)]] <- data.frame(x = location[1, ], y = location[2, ])
  }
}

# # Create a list to store the transect lines
# transect_list <- vector("list", 11)
# for(i in 1:11){
#   # Start with a data frame with two columns and two rows
#   # The first row is the start point, the second row is the finish point
#   # Each transect runs from x = -100 to x = 100, and is at constant height
#   # Transects are stacked vertically, 20 units apart
#   transect_list[[i]] <- data.frame(x = -100:100, y = rep(-100 + (i - 1) * 20, 201))
# }
# 
# # Convert to a list of secr transect objects
# transect_list <- make.transect(transect_list)

transect_list <- read.traps(file = "transects.txt", detector = "transect")

# Simulate capture history
capthist <- sim.capthist(traps = transect_list,
                         popn = droppings,
                         detectfn = 'HHN',
                         detectpar = list(lambda0 = 0.5, sigma = 50),
                         noccasions = 3)

mask <- make.mask(traps = transect_list, buffer = 0, spacing = 10)

# Fit model (or at least try)
mod <- secr.fit(capthist = capthist, trace=T, mask = mask)

